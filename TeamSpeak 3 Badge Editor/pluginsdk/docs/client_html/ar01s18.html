<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Accessing the voice buffer</title><link rel="stylesheet" href="ts3doc.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"><link rel="home" href="index.html" title="TeamSpeak 3 Client SDK Developer Manual"><link rel="up" href="index.html" title="TeamSpeak 3 Client SDK Developer Manual"><link rel="prev" href="ar01s17.html" title="Playback options"><link rel="next" href="ar01s19.html" title="Playing wave files"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><img id="logo" src="images/logo.png"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Accessing the voice buffer</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ar01s17.html"><img src="images/prev.png" alt="Prev"></a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ar01s19.html"><img src="images/next.png" alt="Next"></a></td></tr></table><hr></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="voice_buffer"></a>Accessing the voice buffer</h2></div></div></div><p>The TeamSpeak Client Lib allows users to access the raw playback and capture voice data and even modify it, for example to add effects to the voice. These callbacks are also used by the TeamSpeak client for the voice recording feature.</p><p>Using these low-level callbacks is not required and should be reserved for specific needs. Most SDK applications won't need to implement these callbacks.</p><div class="literallayout"><p><br>
</p></div><p>The following event is called when a voice packet from a client (not own client) is decoded and about to be played over your sound device, but before it is 3D positioned and mixed with other sounds. You can use this function to alter the voice data (for example when you want to do effects on it) or to simply get voice data. The TeamSpeak client uses this function to record sessions.</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">void <b class="fsfunc">onEditPlaybackVoiceDataEvent</b>(</code></td><td><var class="pdparam">serverConnectionHandlerID</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">clientID</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">samples</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">sampleCount</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">channels</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>uint64 <var class="pdparam">serverConnectionHandlerID</var></code>;<br><code>anyID <var class="pdparam">clientID</var></code>;<br><code>short* <var class="pdparam">samples</var></code>;<br><code>int <var class="pdparam">sampleCount</var></code>;<br><code>int <var class="pdparam">channels</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="itemizedlist"><ul type="disc"><li><p><em class="parameter"><code>serverConnectionHandlerID</code></em></p><p>ID of the server connection handler from which the voice data was sent.</p></li><li><p><em class="parameter"><code>clientID</code></em></p><p>ID of the client whose voice data is received.</p></li><li><p><em class="parameter"><code>samples</code></em></p><p>Pointer to the voice data (signed 16 bit @ 48KHz).</p></li><li><p><em class="parameter"><code>sampleCount</code></em></p><p>Number of samples the "samples" variable points to.</p></li><li><p><em class="parameter"><code>channels</code></em></p><p>Number of channels in the sound data.</p></li></ul></div><div class="literallayout"><p><br>
</p></div><p>The following event is called when a voice packet from a client (not own client) is decoded and 3D positioned and about to be played over your sound device, but before it is mixed with other sounds. You can use this function to alter/get the voice data after 3D positioning.</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">void <b class="fsfunc">onEditPostProcessVoiceDataEvent</b>(</code></td><td><var class="pdparam">serverConnectionHandlerID</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">clientID</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">samples</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">sampleCount</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">channels</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">channelSpeakerArray</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">channelFillMask</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>uint64 <var class="pdparam">serverConnectionHandlerID</var></code>;<br><code>anyID <var class="pdparam">clientID</var></code>;<br><code>short* <var class="pdparam">samples</var></code>;<br><code>int <var class="pdparam">sampleCount</var></code>;<br><code>int <var class="pdparam">channels</var></code>;<br><code>const unsigned int* <var class="pdparam">channelSpeakerArray</var></code>;<br><code>unsigned int* <var class="pdparam">channelFillMask</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="itemizedlist"><ul type="disc"><li><p><em class="parameter"><code>serverConnectionHandlerID</code></em></p><p>ID of the server connection handler from which the voice data was sent.</p></li><li><p><em class="parameter"><code>clientID</code></em></p><p>ID of the client whose voice data is received.</p></li><li><p><em class="parameter"><code>samples</code></em></p><p>Pointer to the voice data (signed 16 bit @ 48KHz).</p></li><li><p><em class="parameter"><code>sampleCount</code></em></p><p>Number of samples the "samples" variable points to.</p></li><li><p><em class="parameter"><code>channels</code></em></p><p>Number of channels in the sound data.</p></li><li><p><em class="parameter"><code>channelSpeakerArray</code></em></p><p>An array with <em class="parameter"><code>channels</code></em> entries, defining the speaker each channels represents. The speaker values can be found in the <span class="structname">SPEAKER_*</span> defines within <code class="filename">public_definitions.h</code>.</p><p>For example for stereo (<em class="parameter"><code>channels</code></em> = 2), the array might look liks this:
	</p><pre class="programlisting">channelSpeakerArray[0] = SPEAKER_FRONT_LEFT
channelSpeakerArray[1] = SPEAKER_FRONT_RIGHT</pre></li><li><p><em class="parameter"><code>channelFillMask</code></em></p><p>A pointer to a bit-mask defining which channels are filled. For efficiency reasons, not all channels need to have actual sound data in it. So before this data is used, use this bit-mask to check if the channel is actually filled. If you decide to add data to a channel that is empty, set the bit for this channel in this mask.</p></li></ul></div><p>For example, this callback reports:</p><div class="literallayout"><p>channels = 6<br>
channelSpeakerArray[0] = SPEAKER_FRONT_CENTER<br>
channelSpeakerArray[1] = SPEAKER_LOW_FREQUENCY<br>
channelSpeakerArray[2] = SPEAKER_BACK_LEFT<br>
channelSpeakerArray[3] = SPEAKER_BACK_RIGHT<br>
channelSpeakerArray[4] = SPEAKER_SIDE_LEFT<br>
channelSpeakerArray[5] = SPEAKER_SIDE_RIGHT  // Quite unusual setup<br>
*channelFillMask = 1</p></div><p>This means "samples" points to 6 channel data, but only the SPEAKER_FRONT_CENTER channel has data, the other channels are undefined (not necessarily 0, but undefined).</p><p>So for the first sample, samples[0] has data and samples[1], samples[2], samples[3], samples[4] and samples[5] are undefined.</p><p>If you want to add SPEAKER_BACK_RIGHT channel data you would do something like:</p><pre class="programlisting">*channelFillMask |= 1&lt;&lt;3;  // SPEAKER_BACK_RIGHT is the 4th channel (is index 3) according to *channelSpeakerArray.
for(int i=0; i&lt;sampleCount; ++i){
    samples[3 + (i*channels) ] = getChannelSoundData(SPEAKER_BACK_RIGHT, i); 
}</pre><div class="literallayout"><p><br>
</p></div><p>The following event is called when all sounds that are about to be played back for this server connection are mixed. This is the last chance to alter/get sound.</p><p>You can use this function to alter/get the sound data before playback.</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">void <b class="fsfunc">onEditMixedPlaybackVoiceDataEvent</b>(</code></td><td><var class="pdparam">serverConnectionHandlerID</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">samples</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">sampleCount</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">channels</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">channelSpeakerArray</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">channelFillMask</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>uint64 <var class="pdparam">serverConnectionHandlerID</var></code>;<br><code>short* <var class="pdparam">samples</var></code>;<br><code>int <var class="pdparam">sampleCount</var></code>;<br><code>int <var class="pdparam">channels</var></code>;<br><code>const unsigned int* <var class="pdparam">channelSpeakerArray</var></code>;<br><code>unsigned int* <var class="pdparam">channelFillMask</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="itemizedlist"><ul type="disc"><li><p><em class="parameter"><code>serverConnectionHandlerID</code></em></p><p>ID of the server connection handler from which the voice data was sent.</p></li><li><p><em class="parameter"><code>samples</code></em></p><p>Pointer to the voice data (signed 16 bit @ 48KHz).</p></li><li><p><em class="parameter"><code>sampleCount</code></em></p><p>Number of samples the "samples" variable points to.</p></li><li><p><em class="parameter"><code>channels</code></em></p><p>Number of channels in the sound data.</p></li><li><p><em class="parameter"><code>channelSpeakerArray</code></em></p><p>An array with <em class="parameter"><code>channels</code></em> entries, defining the speaker each channels represents. The speaker values can be found in the <span class="structname">SPEAKER_*</span> defines within <code class="filename">public_definitions.h</code>.</p><p>For example for stereo (<em class="parameter"><code>channels</code></em> = 2), the array might look liks this:
	</p><pre class="programlisting">channelSpeakerArray[0] = SPEAKER_FRONT_LEFT
channelSpeakerArray[1] = SPEAKER_FRONT_RIGHT</pre></li><li><p><em class="parameter"><code>channelFillMask</code></em></p><p>A pointer to a bit-mask of which channels are filled. For efficiency reasons, not all channels need to have actual sound data in it. So before this data is used, use this bit-mask to check if the channel is actually filled. If you decide to add data to a channel that is empty, set the bit for this channel in this mask.</p></li></ul></div><div class="literallayout"><p><br>
</p></div><p>The following event is called after sound is recorded from the sound device and is preprocessed. This event can be used to get/alter recorded sound. Also it can be determined if this sound will be send, or muted. This is used by the TeamSpeak client to record sessions.</p><p>If the sound data will be send, (*edited | 2) is true. If the sound data is changed, set bit 1 (*edited |=1). If the sound should not be send, clear bit 2. (*edited &amp;= ~2)</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">void <b class="fsfunc">onEditCapturedVoiceDataEvent</b>(</code></td><td><var class="pdparam">serverConnectionHandlerID</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">samples</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">sampleCount</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">channels</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">edited</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>uint64 <var class="pdparam">serverConnectionHandlerID</var></code>;<br><code>short* <var class="pdparam">samples</var></code>;<br><code>int <var class="pdparam">sampleCount</var></code>;<br><code>int <var class="pdparam">channels</var></code>;<br><code>int* <var class="pdparam">edited</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="itemizedlist"><ul type="disc"><li><p><em class="parameter"><code>serverConnectionHandlerID</code></em></p><p>ID of the server connection handler from which the voice data was sent.</p></li><li><p><em class="parameter"><code>samples</code></em></p><p>Pointer to the voice data (signed 16 bit @ 48KHz).</p></li><li><p><em class="parameter"><code>sampleCount</code></em></p><p>Number of samples the "samples" variable points to.</p></li><li><p><em class="parameter"><code>channels</code></em></p><p>Number of channels in the sound data.</p></li><li><p><em class="parameter"><code>edited</code></em></p><p>When called, bit 2 indicates if the sound is about to be sent to the server.</p><p>On return, set bit 1 if the sound data was changed.</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="voicerecording"></a>Voice recording</h3></div></div></div><p>When using the above callbacks to record voice, you should notify the server when recording starts or stops with the following functions:</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">unsigned int <b class="fsfunc">ts3client_startVoiceRecording</b>(</code></td><td><var class="pdparam">serverConnectionHandlerID</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>uint64 <var class="pdparam">serverConnectionHandlerID</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">unsigned int <b class="fsfunc">ts3client_stopVoiceRecording</b>(</code></td><td><var class="pdparam">serverConnectionHandlerID</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>uint64 <var class="pdparam">serverConnectionHandlerID</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="itemizedlist"><ul type="disc"><li><p><em class="parameter"><code>serverConnectionHandlerID</code></em></p><p>ID of the server connection handler on which voice recording should be started or stopped.</p></li></ul></div><p>Returns <em class="structfield"><code>ERROR_ok</code></em> on success, otherwise an error code as defined in <code class="filename">public_errors.h</code>.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s17.html"><img src="images/prev.png" alt="Prev"></a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ar01s19.html"><img src="images/next.png" alt="Next"></a></td></tr><tr><td width="40%" align="left" valign="top">Playback options </td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="images/home.png" alt="Home"></a></td><td width="40%" align="right" valign="top"> Playing wave files</td></tr></table></div></body></html>
